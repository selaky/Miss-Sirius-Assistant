# 方案一：虚拟机

采用精简版虚拟机。
优点：可提前替用户配好环境，绝对的后台操作，风险低。开发难度小，不需要新增任何代码。
缺点：硬盘和内存占用大，用户抱有抗拒心理，且存在用户不会使用。

# 方案二：尽量缩短占用鼠标时间

优点：性能占用低，不需要用户实现外操作，风险低，比所有框架自带点击方案都更优。
缺点：依然会频繁抢占鼠标，在其他连点器已经做到真正后台点击的情况下没有优势。

## 游戏后台点击机制逆向分析总结

### 1. 目标程序输入判定逻辑 (Input Handling)

该游戏采用极其严格的混合校验机制，并非单纯读取消息队列参数：

* **物理指针强校验**：处理 `WM_LBUTTONUP` 消息时，游戏会直接调用底层 API (如 `GetCursorPos`) 校验物理鼠标是否位于按钮矩形范围内。若指针移出，判定为“操作取消”。
* **激活状态强校验**：游戏会忽略非激活（后台）状态下的鼠标消息，或在处理输入前检查 `WM_ACTIVATE` 状态。
* **逻辑时序**：点击必须包含完整的 Down/Up 序列，但实测对按压持续时间无强制帧数要求，原子级操作即可被识别。

### 2. 成功的实现流程 (Implementation Workflow)

为了绕过限制并实现最佳体验（无感操作），必须在一个原子操作周期内利用阻塞特性完成“环境伪造”。

**核心步骤序列：**

1. **保存现场**：记录当前物理鼠标坐标 (`GetCursorPos`)。
2. **伪造激活**：向游戏窗口发送激活消息 (`SendMessage(hwnd, WM_ACTIVATE, WA_ACTIVE, 0)`)。
    * *优化：先发送消息利用其阻塞时间处理游戏内部状态，此时物理鼠标尚未被劫持。*
3. **物理瞬移**：将物理鼠标强制移动到游戏按钮坐标 (`SetCursorPos`)。
    * *注意：鼠标劫持窗口期由此刻开始 (Start of Lock)。*
4. **同步按下**：发送鼠标按下指令 (`SendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lparam)`)。
5. **极速响应**：依靠 `SendMessage` 的阻塞特性产生的自然开销即可满足时序要求。
6. **同步抬起**：发送鼠标抬起指令 (`SendMessage(hwnd, WM_LBUTTONUP, 0, lparam)`)。
    * *关键：必须使用 SendMessage 确保游戏处理完 UP 事件前，物理鼠标绝对不动。*
7. **归位现场**：**立即**将物理鼠标瞬移回原始坐标 (`SetCursorPos`)。
    * *注意：鼠标劫持窗口期由此刻结束 (End of Lock)。用户重获控制权。*
8. **状态复原**：发送失去焦点消息 (`SendMessage(hwnd, WM_ACTIVATE, WA_INACTIVE, 0)`)。
    * *优化：在鼠标归位后清理现场，避免清理过程占用鼠标时间。防止游戏长期占用资源或误判状态。*

### 3. 关键技术点

* **SendMessage 的决定性作用**：在此流程中不可使用 `PostMessage`。`SendMessage` 的阻塞机制保证了“按下”和“抬起”在物理鼠标移走之前**绝对完成**。这是实现 0ms 延时且不漏点的前提。
* **坐标系转换**：`SetCursorPos` 使用屏幕坐标 (Screen Coordinates)，消息参数 `lParam` 使用客户区坐标 (Client Coordinates)，需分别计算。

# 方案三：DLL 注入 + Hook

优点：用户体验最好，实现了真正的后台操作。
缺点：有一定风险，游戏本身不担心封号，但要注意，不要导致用户电脑上其他联机游戏被反作弊系统误报造成损失，同时，尽量减少被杀毒软件当做病毒的风险。
具体内容参考规划书。
