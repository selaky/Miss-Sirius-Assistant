本文件的内容为开发 Hook 相关功能期间，对 AI 使用的提示词归档。

本文档为人类后续进行开发可以复用的提示词模式归档，如果你是 AI, 不用在意这篇文档.

我要给这个游戏脚本加上 dll + Hook 的真正后台点击。但是目前计划还不是很明确，需要你协助我完善模糊的需求，制定一份完整的全景规划。我们不讨论、不规定具体的代码，而是先保证项目在往正确的、符合我预期的方向上前进，并且为之后实际开发窗口的提示词做好准备。

目前已经测试过，按照以下流程，能够在不使用注入的情况下完成后台点击：
**核心步骤序列：**

1. **保存现场**：记录当前物理鼠标坐标 (`GetCursorPos`)。
2. **伪造激活**：向游戏窗口发送激活消息 (`SendMessage(hwnd, WM_ACTIVATE, WA_ACTIVE, 0)`)。
    * *优化：先发送消息利用其阻塞时间处理游戏内部状态，此时物理鼠标尚未被劫持。*
3. **物理瞬移**：将物理鼠标强制移动到游戏按钮坐标 (`SetCursorPos`)。
    * *注意：鼠标劫持窗口期由此刻开始 (Start of Lock)。*
4. **同步按下**：发送鼠标按下指令 (`SendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lparam)`)。
5. **极速响应**：依靠 `SendMessage` 的阻塞特性产生的自然开销即可满足时序要求。
6. **同步抬起**：发送鼠标抬起指令 (`SendMessage(hwnd, WM_LBUTTONUP, 0, lparam)`)。
    * *关键：必须使用 SendMessage 确保游戏处理完 UP 事件前，物理鼠标绝对不动。*
7. **归位现场**：**立即**将物理鼠标瞬移回原始坐标 (`SetCursorPos`)。
    * *注意：鼠标劫持窗口期由此刻结束 (End of Lock)。用户重获控制权。*
8. **状态复原**：发送失去焦点消息 (`SendMessage(hwnd, WM_ACTIVATE, WA_INACTIVE, 0)`)。
    * *优化：在鼠标归位后清理现场，避免清理过程占用鼠标时间。防止游戏长期占用资源或误判状态。*

从以上流程中我们可以得到启发：使用 Hook 时，我们需要发送虚假的鼠标位置以及伪造激活状态。

我推测，通过自定义控制器能够实现自定义点击流程。
MAA Framework 自带的 Win32 点击控制，可以从以下仓库中看到：<https://github.com/MaaXYZ/MaaFramework/tree/main/source/MaaWin32ControlUnit>

请你阅读项目本身，还有 MAA Framework 的相关信息，确保你知晓必要的背景知识。然后给我采访一下，到项目实际落地为止，你认为我还有什么模糊的、没有确定的地方？有哪些需要我决策的地方？并且给出推荐的建议。

1. 需要 Hook 的 API 有 `GetCursorPos` 和 `GetForegroundWindow`，推测通过这两个 API, 应该就能实现目标了，其他的 API 之后视情况再考虑。键盘相关的 API 是否hook都可以，因为这个游戏目前没有要用键盘的地方，是纯鼠标操作的。
2. 注入方式需要你帮我考虑一下。这个游戏本身没有反作弊的风险，但是要预防用户电脑上还有其他带反作弊的联机游戏，不要导致用户其他游戏被误封，同时也尽量减少被杀毒软件报毒的风险。
3. 技术选择也由你来考虑，选择你认为最合适的。
4.使用自定义控制器，方便用户一键切换。
4. 对于触发时机问题，你帮我看看下面这个方案是否可行合理，我对这方面懂得不多，描述可能不够准确。我计划复用项目已经有的任务体系，对“注入”增加一个单独的任务，和目前已有的“跑图”和“竞技场”任务平行且放在最前面，通过一个 action 类型为 command 的节点来实现，执行时会自动去运行另外的注入程序，运行结束后自动关闭。用户勾选以后，点击执行就会自动先执行注入任务，然后开始执行真正游戏任务。不选择在脚本开始时自行启动，是为了防止用户中途重启游戏。
5. 参考上一条，即用户可以在 gui 界面手动勾选，要不要在执行任务前先注入，此选项默认开启，因此等同于用户每次开始执行任务前都会注入一次。
6. 对权限没有特别要求，要用管理员权限也没问题。
7. 如果失败不自行回退。如果能检测到错误，就在日志和GUI（GUI 输出依赖 focus 字段）报错，让用户自行切换到原生控制器。目的是避免用户觉得自己设置的和脚本执行的不一样，产生困惑。
8. 开发语言选择 c++
9. 项目结构你自行规划，要求是易于维护，不要干扰到其他模块，并且不要忘了在构建时被一起打包进去。
10. 反作弊内容同第二条，只要避免其他游戏被误判就行。
11. 已经成功的测试并没有使用hook，因此代码参考价值不大，其目的只是为了获知游戏的点击检测机制。
现在根据以上内容，我授权你给我生成一份完整的规划书，并创建文档保存。再次强调，这份规划书不讨论、不规定具体的代码，而是先保证项目在往正确的、符合我预期的方向上前进，并且为之后实际开发窗口的提示词做好准备。

请参考后台点击Hook方案规划书中的计划，进行后台点击的第一阶段开发。如果你有任何东西不知道，去查询而不是自己猜测。
需要额外注意的点有：

1. 对点击测试程序的要求是：双击之后可以运行，会输出相关信息便于调试，可以点击指定坐标或者中心位置。
2. 构建时不要指定 Visual Studio 的版本，电脑上有什么就用什么。注意编码格式问题。
3. 避免反复注入
4. minhook 的正确地址是 <https://github.com/TsudaKageyu/minhook>

请参考后台点击Hook方案规划书中的计划，进行后台点击的第三阶段开发。如果你有任何东西不知道，去查询而不是自己猜测。
验收方式要易于操作，且有相应输出信息。

请参考后台点击Hook方案规划书中的计划，进行后台点击的第四阶段开发。如果你有任何东西不知道，去查询而不是自己猜测。

我需要在后台点击 Hook 方案规划书的基础上增加一个修正版计划。但我们先不修改任何代码或者文档，我们先把开发方向搞清楚。
原计划第四阶段实际发现无法实施，GUI MFAAvalonia不支持自定义控制器，现在该计划作废，旧文件预计归档。
我现在的新计划是不再自己实现自定义控制器。而是修改 MAA Framework 自带的 Win32 控制器，在构建时进行把原本点击的 DLL 改名，用我们自己的 DLL 进行顶替。其他方法全都透传，只增加我们自己 Hook 实现的点击方法。由于 GUI 中能选择的点击方法是固定写死的，因此考虑把自带控制器中的其中一个方法（例如 `SendMessage`）替换成自己实现的方法。
现在计划还比较模糊，请你采访我，帮助我完善具体的规划。对于每个问题给出你推荐的方案。你可以查询项目内部以及外部的代码和文档。如果我的计划中有哪里是错误的，也请你指出。

针对你的问题，我做出以下回答，你看一下我的想法有没有问题。
如果没有问题的话，就帮我写一份修正版的后台方案规划书。授权你这里创建一个新的文档，旧文档就此归档。注意文档中尽量不要有废话，不要用长篇大论解释为什么要这么做，仅包含必要要点和工作流程，用于指导后续开发。文档不讨论、不规定具体的代码，而是先保证项目在往正确的、符合我预期的方向上前进，并且为之后实际开发窗口的提示词做好准备。
回答：

1. 选择方案 B Proxy DLL, 这样实现起来简单点，而且不容易将来出冲突。
2. 选择替换 send message。因为原来的 send message 不能生效。虽然 send message with cursor pos 语义上更接近，但它好歹本来能工作，如果我们自己修改的版本不生效，用户还能换回一个能生效的选项。
3. 保持和原方案一致：每次进行点击前，先检查一下当前有没有注入。如果没有注入，就进行注入，然后再执行后续激活和点击等流程；
4. 截图方式不修改，用 MAA Framework 自带的，不再重复造轮子
5. 鉴于第一个问题选了方案 B, 所以这里就不需要 MAA Framework 的源码了。可以在计划里加上一条：开发的时候，写一个小脚本去读取当前对应的 DLL 文件的导出函数表。
6. 此问题参考回答2， 如果修改后的点击方式不生效，或者用户不想用后台点击，可以自行切换到 Send message with cursor pos。我们这里不做兜底或回退。

帮我检查一下后台点击Hook方案规划书v2当中是否包含事实性错误？按照此方案是否能够成功推进至项目顺利完成，且按照预期工作？

如果你确保要补充的内容正确、有据可循，而非主观猜测，就将其写入文档。如果还不能确定，就再去查询；或者实在查不到，请告诉我不能确定。
注意：文档中不要有长篇大论的废话，仅包含必要内容，也不要规定具体的代码实现方式。

请参照《后台点击Hook方案规划书v2》，进行第四阶段的开发。注意，如果你有任何东西不清楚，去查询，而不是自己猜测。

我的意见是需要应对MAA Framework 接口变化和C++ ABI 兼容性。对于这二者是否存在快速便捷检测的方法？说说你的判断。
不考虑游戏端行为变化和新增点击方法。
